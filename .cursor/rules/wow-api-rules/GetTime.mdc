---
description: 
globs: 
alwaysApply: false
---
# WoW API: GetTime

## Function Overview
`GetTime()` returns the system uptime of your computer in seconds with millisecond precision, providing a reliable timing reference for addon operations.

## Syntax
```lua
seconds = GetTime()
```

## Returns
- **seconds** (number): The current system uptime in seconds with millisecond precision (e.g., 60123.558)

## Important Characteristics
- **Frame-based updates**: Value only updates once per rendered frame
- **High precision**: Millisecond precision for accurate timing measurements
- **System uptime**: Based on computer uptime, not game session time
- **Consistent reference**: Reliable baseline for duration calculations and timing operations

## Usage Examples

### Basic Timing Operations
```lua
-- Get current time
local currentTime = GetTime()
print("Current system uptime:", currentTime, "seconds")

-- Time difference calculation
local startTime = GetTime()
-- ... some operation ...
local endTime = GetTime()
local duration = endTime - startTime
print("Operation took:", duration, "seconds")
```

### Cooldown Tracking for Rotations
```lua
local lastCastTime = 0
local globalCooldown = 1.5 -- GCD duration

local function CanCastSpell()
    local currentTime = GetTime()
    local timeSinceLastCast = currentTime - lastCastTime
    
    if timeSinceLastCast >= globalCooldown then
        return true
    else
        local remainingCooldown = globalCooldown - timeSinceLastCast
        return false, remainingCooldown
    end
end

local function CastSpell(spellName)
    local canCast, remaining = CanCastSpell()
    if canCast then
        -- Cast the spell
        lastCastTime = GetTime()
        print("Casting:", spellName)
    else
        print("GCD remaining:", string.format("%.2f", remaining), "seconds")
    end
end
```

### Performance Monitoring
```lua
local performanceTracker = {}

local function StartProfiling(operationName)
    performanceTracker[operationName] = GetTime()
end

local function EndProfiling(operationName)
    local startTime = performanceTracker[operationName]
    if startTime then
        local duration = GetTime() - startTime
        print(operationName .. " took:", string.format("%.3f", duration * 1000), "ms")
        performanceTracker[operationName] = nil
    end
end

-- Usage example
StartProfiling("RotationCalculation")
-- ... perform rotation logic ...
EndProfiling("RotationCalculation")
```

### Debouncing User Input
```lua
local lastActionTime = 0
local debounceDelay = 0.5 -- 500ms debounce

local function DebounceAction(actionFunction)
    local currentTime = GetTime()
    if currentTime - lastActionTime >= debounceDelay then
        lastActionTime = currentTime
        actionFunction()
    else
        print("Action debounced - please wait")
    end
end

-- Usage
local function ToggleRotation()
    print("Rotation toggled!")
end

-- This will only execute if 500ms have passed since last call
DebounceAction(ToggleRotation)
```

### Periodic Task Scheduling
```lua
local scheduler = {}

local function ScheduleRepeatingTask(taskName, interval, taskFunction)
    scheduler[taskName] = {
        interval = interval,
        lastRun = GetTime(),
        task = taskFunction
    }
end

local function UpdateScheduler()
    local currentTime = GetTime()
    for taskName, data in pairs(scheduler) do
        if currentTime - data.lastRun >= data.interval then
            data.task()
            data.lastRun = currentTime
        end
    end
end

-- Schedule a task to run every 5 seconds
ScheduleRepeatingTask("StatusUpdate", 5.0, function()
    print("Status check at:", GetTime())
end)

-- Call UpdateScheduler() in your OnUpdate handler
```

### Animation and UI Timing
```lua
local animationStart = 0
local animationDuration = 2.0 -- 2 seconds

local function StartAnimation(frame)
    animationStart = GetTime()
    frame.isAnimating = true
end

local function UpdateAnimation(frame)
    if not frame.isAnimating then return end
    
    local currentTime = GetTime()
    local elapsed = currentTime - animationStart
    local progress = elapsed / animationDuration
    
    if progress >= 1.0 then
        -- Animation complete
        progress = 1.0
        frame.isAnimating = false
    end
    
    -- Apply animation (e.g., fade in)
    frame:SetAlpha(progress)
end
```

### Combat Duration Tracking
```lua
local combatStartTime = nil
local totalCombatTime = 0

local function OnCombatStart()
    combatStartTime = GetTime()
    print("Combat started")
end

local function OnCombatEnd()
    if combatStartTime then
        local combatDuration = GetTime() - combatStartTime
        totalCombatTime = totalCombatTime + combatDuration
        
        print(string.format("Combat lasted: %.2f seconds", combatDuration))
        print(string.format("Total combat time this session: %.2f seconds", totalCombatTime))
        
        combatStartTime = nil
    end
end

-- Register for combat events
local combatFrame = CreateFrame("Frame")
combatFrame:RegisterEvent("PLAYER_REGEN_DISABLED") -- Enter combat
combatFrame:RegisterEvent("PLAYER_REGEN_ENABLED")  -- Leave combat
combatFrame:SetScript("OnEvent", function(self, event)
    if event == "PLAYER_REGEN_DISABLED" then
        OnCombatStart()
    elseif event == "PLAYER_REGEN_ENABLED" then
        OnCombatEnd()
    end
end)
```

## Important Considerations

### Frame-Based Updates
- **Limitation**: GetTime() only updates once per frame render
- **Impact**: Multiple calls within the same frame return identical values
- **Solution**: For finer precision, use `GetTimePreciseSec()` or `debugprofilestop()`

### Performance Implications
- **Efficient**: Very lightweight function call
- **Frame rate dependent**: Update frequency tied to FPS
- **High FPS impact**: At high frame rates, may return identical values across frames

### Precision Notes
- **Millisecond accuracy**: Suitable for most addon timing needs
- **System based**: Uses computer uptime, not game session time
- **Consistent**: Reliable for duration calculations and comparisons

## Common Use Cases in Hero Rotation

### Rotation Timing
- **GCD tracking**: Monitor global cooldown completion
- **Spell queueing**: Time spell casts for optimal DPS
- **Ability prioritization**: Compare spell cooldowns and priorities

### Performance Monitoring  
- **Rotation calculations**: Profile addon performance impact
- **Network compensation**: Combine with latency data for timing adjustments
- **Resource optimization**: Monitor expensive operations

### User Interface
- **Animation timing**: Smooth UI transitions and effects  
- **Input debouncing**: Prevent rapid-fire button presses
- **Status updates**: Periodic information refresh

## API Availability
- **Added**: Patch 1.0.0 (Classic) / Patch 1.13.2 (Classic re-release)
- **Enhanced**: Patch 4.3.0 (Frame-based update limitation added)
- **Current**: Available in all WoW flavors

## Related APIs
- `GetTimePreciseSec()` - Higher precision timing (sub-frame accuracy)
- `debugprofilestop()` - Microsecond precision for performance profiling
- `GetGameTime()` - In-game time (hours/minutes)
- `time()` - Unix timestamp
- `date()` - Formatted date/time strings
- `C_Timer.After()` - Schedule delayed function calls
- `C_Timer.NewTimer()` - Create repeating timers

## Performance Tips
- **Cache time values**: Store GetTime() result if used multiple times per frame
- **Batch calculations**: Group timing operations to minimize calls
- **Consider alternatives**: Use GetTimePreciseSec() for sub-frame precision needs
- **Profile timing code**: Use debugprofilestop() to measure timing operation overhead

